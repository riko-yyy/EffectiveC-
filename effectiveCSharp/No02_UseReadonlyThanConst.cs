using System;
namespace effectiveCSharp.Util
{
    /// <summary>
    /// constよりreadonlyを利用する
    /// </summary>
    public class No02_UseReadonlyThanConst
    {
        //コンパイル時定数
        public const int Millennium = 2000;

        //実行時定数
        public static readonly int ThisYear = 2020;


        public No02_UseReadonlyThanConst()
        {
            //目的：
            //①固定値が永続的な固定値か、変更し得る固定値かで使い分けるとビルドの手間が減る

            //挙動の違い：
            //--------------------------------------------------------------------------------------
            var now = DateTime.Now;
            //コンパイル時定数
            if (now.Year == Millennium)            
            {
                //コンパイル結果は、下記のコンパイル結果と同じ
                //if (now.Year == 2000)
                //=>プリミティブ（数値、文字列、null）のみ利用できる（newは使用できない）
            }

            //実行時定数
            if (now.Year == ThisYear)
            {
                //実行時にreadonly変数を参照しに行く
                //=>全ての型で利用できる
                //=>同じクラスの別インスタンスにそれぞれの定数を設定可能
            }


            //使い分け：
            //--------------------------------------------------------------------------------------
            //1)アセンブリ変更時の有意性

            //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            //readonly：ビルドし直さなくていいい
            //アセンブリの中で定数として実行時定数を用いていれば、そのアセンブリを参照していたアプリケーションをリビルドしなくていい
            //逆にconstで記述していれば、該当アセンブリの値変更があった場合に、そのアセンブリを参照している全てのアプリケーションのリビルドが必要

            //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            //const：任意のタイミングで適用可能
            //上記の場合でアセンブリを更新しても、ビルドしないと適用されないことを生かす
            //逆に明示的なタイミングで、アセンブリを利用するアプリケーションを更新する必要があるのならこちらを利用する

        }
    }
}
