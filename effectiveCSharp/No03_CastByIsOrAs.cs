using System;
using effectiveCSharp.Util;
namespace effectiveCSharp
{
    /// <summary>
    /// キャストにはisもしくはasを用いる
    /// </summary>
    public class No03_CastByIsOrAs
    {
        public No03_CastByIsOrAs()
        {
            //目的：
            //①as,isはユーザー定義の変換を行わないため安全かつ実行効率もよい
            //②as,is実行時の型が一致しているか派生系かをチェックするだけでキャストは行わないため、情報の損失がない

            //例：
            //--------------------------------------------------------------------------------------
            //1)可読性とキャストとの違い
            object o = new object();
            //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            //メリット①：これしかない。みやすい。try句不要。nullチェックも兼用
            //パターン１
            MyType t1 = o as MyType;
            if (t1 != null)
            {
                //処理
            }
            else
            {
                //例外
            }

            //パターン２
            try {
                //仮に実行時の型がSecondTypeで、ユーザー定義の変換演算子が定義されていても、キャストはコンパイル時に走査するため、エラーとなる
                MyType t2 = (MyType)o;
                //処理

            } catch {
                //例外
            }

            //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            //メリット②：ダウンキャストを回避できる。数値に生じる暗黙的型変換と精度。
            //as以降の型か派生の型のみ成功
            string t3 = o as string;
            //ダウンキャスト可能なら成功
            string t4 = (string)o;

            //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            //デメリット①：null許容でないと使用できない
            int? t5 = o as int?;

            //=>varと合わせて利用すると後続処理までnull許容を引っ張らない
            var t6 = o as int?;

            //比較：
            //--------------------------------------------------------------------------------------
            //結果がoの型に応じて変わる
            var cast = (MyType)o;

            //結果がoの型にかかわらず一定
            var asis = o as MyType;

            //検証：
            //--------------------------------------------------------------------------------------
            //実行時の厳密な型を検証
            var isValid = cast.GetType() == typeof(MyType);

            //派生クラスも許容する検証
            var isValid1 = cast is MyType;

        }


    }
}
